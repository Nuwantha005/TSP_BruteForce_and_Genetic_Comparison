/* autogenerated by Processing revision 1293 on 2023-12-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TSP_BruteForce_and_Genetic_Comparison extends PApplet {

int no_of_cities = 25;
int popSize = 500;
float recordDist = 999999999;
float mutationRate = 0.4f;
int totalPerm, currentPerm;
float recordDist_bruteForce;

int[] currentBest = new int[no_of_cities];
int[] order = new int[no_of_cities];
int[] order_bruteForce = new int[no_of_cities];
PVector[] cities = new PVector[no_of_cities];
int[] shortest = new int[no_of_cities];
int[] shortest_bruteForce = new int[no_of_cities];
element[] population = new element[popSize];
int no_of_generations = 1;
FloatList shortestList = new FloatList();


public void setup() {
    /* size commented out by preprocessor */;
    
    totalPerm = fact(no_of_cities);
    currentPerm = 1;

    //generating random city list
    for (int i = 0; i < no_of_cities; ++i) {
        cities[i] = new PVector(random(50, width / 2 - 50), random(50, height - 50));
        order[i] = i;
        order_bruteForce[i] = i;
        shortest[i] = i;
        shortest_bruteForce[i] = i;
    }
    recordDist = calcDist(cities, order);
    recordDist_bruteForce = recordDist;
    shortestList.append(recordDist);
    println(recordDist);
    
    //generating random population
    for (int i = 0; i < popSize; ++i) {
        int[] tempArr = new int[no_of_cities];
        clone(order, tempArr, no_of_cities);
        shuffle(tempArr, no_of_cities, 100);
        element newElement = new element(tempArr, no_of_cities);
        population[i] = newElement;
    }
    
}

public void draw() {
    background(0);
    fill(255);
    
    calculateFitness();
    normalizeFitness(population);
    createNextGeneration();
    
    for (int i = 0; i < no_of_cities; ++i) {
        circle(cities[i].x, cities[i].y,5);
    }
    
    
    stroke(255);
    strokeWeight(1);
    noFill();
    beginShape();
    for (int i = 0; i < no_of_cities; ++i) {
        vertex(cities[currentBest[i]].x, cities[currentBest[i]].y);
    }
    endShape();
    
    stroke(90,255,100);
    strokeWeight(3);
    noFill();
    beginShape();
    for (int i = 0; i < no_of_cities; ++i) {
        vertex(cities[shortest[i]].x, cities[shortest[i]].y);
    }
    endShape();
    
    textSize(20);
    text("No of Generations:  " + no_of_generations ,10, 30);
    // text(String.format("%.2f", percentage) + " % Complete", width - 165, 30);
    text("Best Distance: " + recordDist, 10, height - 20);
    
    no_of_generations++;
    
    
    
    //BrruteForce Code
    for (int i = 0; i < no_of_cities; ++i) {
        circle(width / 2 + cities[i].x, cities[i].y,5);
    }
    
    //Find the largest x s.t. P[x] < P[x+]
    int largestI = -1;
    for (int i = 0; i < no_of_cities - 1; i++) {
        if (order_bruteForce[i] < order_bruteForce[i + 1]) {
            largestI = i;
        }
    }
    if (largestI == -1) {
        stroke(90,255,100);
        strokeWeight(3);
        noFill();
        beginShape();
        for (int i = 0; i < no_of_cities; ++i) {
            vertex(width / 2 + cities[shortest_bruteForce[i]].x, cities[shortest_bruteForce[i]].y);
        }
        endShape();
        
        noLoop();
    } else {
        
        int largestJ = -1;
        //Find the larges y s.t. P[x] < P[y]
        for (int j = 0; j < no_of_cities; ++j) {
            if (order_bruteForce[largestI] < order_bruteForce[j]) {
                largestJ = j;
            }
        }
        
        //Swap P[x] and P[y]
        int temp = order_bruteForce[largestI];
        order_bruteForce[largestI] = order_bruteForce[largestJ];
        order_bruteForce[largestJ] = temp;
        
        //Reverse P[x+1 ... n]
        int reverseArrayLength = no_of_cities - largestI - 1;
        int[] partToBeRevesed = new int[reverseArrayLength];
        int[] revesedArray = new int[reverseArrayLength];
        
        for (int i = 1; i < reverseArrayLength + 1; ++i) {      //creating a new array with items to be reversed
            partToBeRevesed[i - 1] = order_bruteForce[i + largestI];
        }
        for (int k = 0; k < reverseArrayLength; ++k) {      //reversing the array
            revesedArray[k] = partToBeRevesed[reverseArrayLength - (k + 1)];
        }
        for (int k = 0; k < reverseArrayLength; ++k) {      //adding reversed array to the main array
            order_bruteForce[largestI + k + 1] = revesedArray[k];
        }
        
        float dis = calcDist(cities, order_bruteForce);
        if (dis < recordDist_bruteForce) {
            for (int i = 0; i < no_of_cities; ++i) {
                shortest_bruteForce[i] = order_bruteForce[i];
            }
            recordDist_bruteForce = dis;
            println(recordDist_bruteForce);
        }
        
        
        stroke(255);
        strokeWeight(1);
        noFill();
        beginShape();
        for (int i = 0; i < no_of_cities; ++i) {
            vertex(width / 2 + cities[order_bruteForce[i]].x, cities[order_bruteForce[i]].y);
        }
        endShape();
        
        stroke(90,255,100);
        strokeWeight(3);
        noFill();
        beginShape();
        for (int i = 0; i < no_of_cities; ++i) {
            vertex(width / 2 + cities[shortest_bruteForce[i]].x, cities[shortest_bruteForce[i]].y);
        }
        endShape();
    }
    float percentage = (PApplet.parseFloat(currentPerm) / PApplet.parseFloat(totalPerm)) * 100;
    textSize(20);
    text("Permutation " + currentPerm + " of " + totalPerm ,width / 2 + 10, 30);
    text(String.format("%.2f", percentage) + " % Complete", width - 165, 30);
    text("Best Distance: " + recordDist_bruteForce, width / 2 + 10, height - 20);
    currentPerm++;
    
}
public void calculateFitness(){
    float currentRecord = 999999999;
    for (int i = 0; i < popSize; ++i) {
        int[] temp = new int[no_of_cities];
        population[i].getCities(temp);
        float dist = calcDist(cities, temp);
        if (dist < recordDist) {
            recordDist = dist;
            float prevBest = shortestList.get(shortestList.size() - 1);
            println(recordDist, " - ", String.format("%.5f", (prevBest - recordDist) * 100 / prevBest ), "% reduction");
            shortestList.append(recordDist);
            clone(temp, shortest, no_of_cities);
        }
        if (dist < currentRecord) {
            currentRecord = dist;
            clone(temp, currentBest, no_of_cities);
        }

        population[i].setFitness(1 / (pow(dist, 8) + 1));
    }
}

public void normalizeFitness(element[] array){
    float sum = 0;
    for (int i = 0; i < popSize; ++i) {
        sum += array[i].getFitness();
    }
    for (int i = 0; i < popSize; ++i) {
        array[i].setFitness(array[i].getFitness() / sum);
    }
}

public void createNextGeneration(){
    element[] newPop = new element[popSize];
    //generating random population
    for (int i = 0; i < popSize; ++i) {
        int[] tempArr = new int[no_of_cities];
        clone(order, tempArr, no_of_cities);
        shuffle(tempArr, no_of_cities, 100);
        element newElement = new element(tempArr, no_of_cities);
        newPop[i] = newElement;
    }

    for (int i = 0; i < popSize; ++i) {
        int[] order1 = new int[no_of_cities];
        pickOne(population, order1);
        // int[] order2 = new int[no_of_cities];
        // pickOne(population, order2);
        //crossover
        mutate(order1, mutationRate);
        newPop[i].setCities(order1);
    }
    clone(newPop, population, popSize);
}


public void pickOne(element[] pop, int[] pickedOne){
    int index = 0;
    float r = random(1);

    while (r > 0) {
        if (index == popSize) {
            break;
        }
        r -= pop[index].getFitness();
        index++;
    }
    if (index != 0) {
        index --;
    }
    int[] temp = new int[no_of_cities];
    population[index].getCities(temp);    
    clone(temp, pickedOne, no_of_cities);
}


public void mutate(int[] order, float mutRate){
    for (int i = 0; i < no_of_cities; ++i) {
        if (random(1) < mutRate) {
            int indexA = PApplet.parseInt(random(no_of_cities));
            int indexB = (indexA + 1) % no_of_cities;
            swap(order, indexA, indexB);
        }
    }
}
class element{
    float fitness;
    int no_of_cities;
    int[] cities;

    element(int[] cities_list, int cityCount, float fitness_val){
        fitness = fitness_val;
        no_of_cities = cityCount;
        cities = new int[no_of_cities];
        for (int i = 0; i < no_of_cities; ++i) {
            cities[i] = cities_list[i];
        }
    }

    element(){
        fitness = 0;
        no_of_cities = no_of_cities;
        for (int i = 0; i < no_of_cities; ++i) {
            cities[i] = 0;
        }
    }

    element(int[] cities_list, int cityCount){
        no_of_cities = cityCount;
        cities = new int[no_of_cities];
        for (int i = 0; i < no_of_cities; ++i) {
            cities[i] = cities_list[i];
        }
    }

    public float getFitness(){
        return fitness;
    }

    public void setFitness(float fit){
        fitness = fit;
    }

    public void getCities(int[] list){
        for (int i = 0; i < no_of_cities; ++i) {
            list[i] = cities[i];
        }
    }

    public void setCities(int[] cities_list){
        cities = new int[no_of_cities];
        for (int i = 0; i < no_of_cities; ++i) {
            cities[i] = cities_list[i];
        }
    }
}

public void swap(int[] array, int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}


public void clone(int[] array1,int[] array2, int length) {
    for (int i = 0; i < length; ++i) {
        array2[i] = array1[i];
    }
}

public void clone(element[] array1,element[] array2, int length) {
    for (int i = 0; i < length; ++i) {
        array2[i] = array1[i];
    }
}

public float calcDist(PVector[] points, int[] orderArray) {
    float sum = 0;
    for (int i = 0; i < no_of_cities - 1; ++i) {
        sum += dist(points[orderArray[i]].x,points[orderArray[i]].y,points[orderArray[i+1]].x,points[orderArray[i+1]].y);
        //sum += dist(points[orderArray[i]].x, points[orderArray[i]].y, points.[orderArray[i+1]].x, points[orderArray[i+1]].y);
    }
    return sum;
}

public void shuffle(int[] array,int arSize, int times){
    for (int i = 0; i < times; ++i) {
        swap(array, PApplet.parseInt(random(arSize)), PApplet.parseInt(random(arSize)));
    }
}


public int fact(int n){
    if (n == 0) {
        return 1;
    } else {
        return n * fact(n-1);
    }
}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TSP_BruteForce_and_Genetic_Comparison" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
